<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Workflow Builder - Visual DAG Construction</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&family=Outfit:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0D0D12;
            --bg-secondary: #16161D;
            --bg-tertiary: #1E1E28;
            --accent-primary: #00D4AA;
            --accent-secondary: #7B61FF;
            --accent-tertiary: #FF6B4A;
            --accent-quaternary: #FFD93D;
            --text-primary: #F4F4F6;
            --text-secondary: #8B8B9A;
            --text-muted: #5C5C6D;
            --border: #2A2A36;
            --success: #00D4AA;
            --warning: #FFD93D;
            --error: #FF4757;
            --grid-lines: #1E1E28;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --font-heading: 'Outfit', sans-serif;
            --font-body: 'IBM Plex Sans', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Header */
        .header {
            height: 60px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            backdrop-filter: blur(12px);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--bg-primary);
        }

        .logo-text {
            font-family: var(--font-heading);
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 24px;
            padding: 4px;
            gap: 4px;
        }

        .mode-btn {
            padding: 8px 20px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: var(--font-body);
            font-size: 13px;
            font-weight: 500;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .mode-btn:hover:not(.active) {
            color: var(--text-primary);
        }

        /* Action Buttons */
        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: 13px;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 212, 170, 0.1);
        }

        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: #00e6b8;
            border-color: #00e6b8;
        }

        .btn svg {
            width: 16px;
            height: 16px;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* Node Palette */
        .node-palette {
            width: 240px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 20px;
            overflow-y: auto;
        }

        .palette-title {
            font-family: var(--font-heading);
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
        }

        .palette-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-bottom: 12px;
            cursor: grab;
            transition: all 0.2s ease;
        }

        .palette-item:hover {
            transform: scale(1.02);
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px rgba(0, 212, 170, 0.2);
        }

        .palette-item:active {
            cursor: grabbing;
        }

        .palette-item.agent { border-left: 3px solid var(--accent-primary); }
        .palette-item.groupchat { border-left: 3px solid var(--accent-secondary); }
        .palette-item.sequential { border-left: 3px solid var(--accent-tertiary); }
        .palette-item.parallel { border-left: 3px solid var(--accent-quaternary); }

        .palette-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .palette-icon.agent { background: rgba(0, 212, 170, 0.15); color: var(--accent-primary); }
        .palette-icon.groupchat { background: rgba(123, 97, 255, 0.15); color: var(--accent-secondary); }
        .palette-icon.sequential { background: rgba(255, 107, 74, 0.15); color: var(--accent-tertiary); }
        .palette-icon.parallel { background: rgba(255, 217, 61, 0.15); color: var(--accent-quaternary); }

        .palette-icon svg {
            width: 20px;
            height: 20px;
        }

        .palette-label {
            font-size: 14px;
            font-weight: 500;
        }

        /* Canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .canvas {
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at center, var(--bg-secondary) 0%, var(--bg-primary) 100%),
                repeating-linear-gradient(0deg, transparent, transparent 19px, var(--grid-lines) 19px, var(--grid-lines) 20px),
                repeating-linear-gradient(90deg, transparent, transparent 19px, var(--grid-lines) 19px, var(--grid-lines) 20px);
            background-size: 100% 100%, 20px 20px, 20px 20px;
            position: relative;
        }

        .canvas-content {
            position: absolute;
            width: 4000px;
            height: 4000px;
            transform-origin: 0 0;
        }

        /* SVG for connections */
        .connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        .connection {
            fill: none;
            stroke: var(--text-muted);
            stroke-width: 2;
            stroke-dasharray: 8, 4;
            animation: flowAnimation 1s linear infinite;
            pointer-events: stroke;
            cursor: pointer;
        }

        .connection:hover {
            stroke: var(--accent-primary);
            stroke-width: 3;
        }

        .connection.selected {
            stroke: var(--accent-primary);
            stroke-width: 3;
        }

        @keyframes flowAnimation {
            to { stroke-dashoffset: -12; }
        }

        /* Nodes on Canvas */
        .canvas-node {
            position: absolute;
            width: 220px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
            cursor: move;
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
        }

        .canvas-node:hover {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .canvas-node.selected {
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px rgba(0, 212, 170, 0.3);
        }

        .canvas-node.agent { border-left: 4px solid var(--accent-primary); }
        .canvas-node.groupchat { border-left: 4px solid var(--accent-secondary); }
        .canvas-node.sequential { border-left: 4px solid var(--accent-tertiary); }
        .canvas-node.parallel { border-left: 4px solid var(--accent-quaternary); }

        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .node-type-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .node-type-icon.agent { background: rgba(0, 212, 170, 0.15); color: var(--accent-primary); }
        .node-type-icon.groupchat { background: rgba(123, 97, 255, 0.15); color: var(--accent-secondary); }
        .node-type-icon.sequential { background: rgba(255, 107, 74, 0.15); color: var(--accent-tertiary); }
        .node-type-icon.parallel { background: rgba(255, 217, 61, 0.15); color: var(--accent-quaternary); }

        .node-type-icon svg {
            width: 16px;
            height: 16px;
        }

        .node-title {
            flex: 1;
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .node-body {
            padding: 12px 14px;
        }

        .node-description {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* Ports */
        .port {
            position: absolute;
            width: 14px;
            height: 14px;
            background: var(--bg-tertiary);
            border: 2px solid var(--text-muted);
            border-radius: 50%;
            cursor: crosshair;
            transition: all 0.2s ease;
        }

        .port:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            transform: scale(1.3);
        }

        .port.input {
            left: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .port.output {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .port.input:hover, .port.output:hover {
            transform: translateY(-50%) scale(1.3);
        }

        /* Properties Panel */
        .properties-panel {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .properties-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .properties-title {
            font-family: var(--font-heading);
            font-size: 16px;
            font-weight: 600;
        }

        .properties-close {
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .properties-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .properties-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238B8B9A' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .no-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            text-align: center;
            padding: 40px;
        }

        .no-selection-icon {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .no-selection-text {
            font-size: 14px;
            line-height: 1.6;
        }

        /* Code Editor Mode */
        .code-editor-panel {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
        }

        .code-editor-panel.active {
            display: flex;
        }

        .code-editor-header {
            padding: 16px 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .code-editor-title {
            font-family: var(--font-heading);
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .code-editor-container {
            flex: 1;
            overflow: auto;
            background: var(--bg-primary);
            padding: 24px;
        }

        .code-editor {
            width: 100%;
            min-height: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            font-family: var(--font-mono);
            font-size: 13px;
            line-height: 1.7;
            color: var(--text-primary);
            resize: none;
            tab-size: 2;
        }

        .code-editor:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }

        .empty-state-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 24px;
            opacity: 0.3;
        }

        .empty-state-title {
            font-family: var(--font-heading);
            font-size: 20px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .empty-state-text {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 14px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 12px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--error);
        }

        .toast-icon {
            width: 20px;
            height: 20px;
        }

        .toast.success .toast-icon { color: var(--success); }
        .toast.error .toast-icon { color: var(--error); }

        /* Hidden file input */
        .hidden-input {
            display: none;
        }

        /* Keyboard shortcuts hint */
        .shortcuts-hint {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            padding: 8px 16px;
            background: rgba(22, 22, 29, 0.9);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .shortcut {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .shortcut kbd {
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 11px;
        }

        /* Zoom indicator */
        .zoom-controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .zoom-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .zoom-level {
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 12px;
            font-family: var(--font-mono);
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                </svg>
            </div>
            <span class="logo-text">Agent Workflow Builder</span>
        </div>
        
        <div class="header-actions">
            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="visual">Visual</button>
                <button class="mode-btn" data-mode="code">Code</button>
            </div>
            
            <button class="btn" id="importBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
                </svg>
                Import
            </button>
            <button class="btn" id="exportBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                </svg>
                Export
            </button>
            <button class="btn btn-primary" id="generateBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 18l6-6-6-6M8 6l-6 6 6 6"/>
                </svg>
                Generate Code
            </button>
        </div>
    </header>

    <main class="main-container">
        <aside class="node-palette" id="palette">
            <h3 class="palette-title">Node Types</h3>
            
            <div class="palette-item agent" draggable="true" data-type="agent">
                <div class="palette-icon agent">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                </div>
                <span class="palette-label">Agent Node</span>
            </div>
            
            <div class="palette-item groupchat" draggable="true" data-type="groupchat">
                <div class="palette-icon groupchat">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 00-3-3.87M16 3.13a4 4 0 010 7.75"/>
                    </svg>
                </div>
                <span class="palette-label">Group Chat</span>
            </div>
            
            <div class="palette-item sequential" draggable="true" data-type="sequential">
                <div class="palette-icon sequential">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M5 12h14M12 5l7 7-7 7"/>
                    </svg>
                </div>
                <span class="palette-label">Sequential</span>
            </div>
            
            <div class="palette-item parallel" draggable="true" data-type="parallel">
                <div class="palette-icon parallel">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"/>
                    </svg>
                </div>
                <span class="palette-label">Parallel</span>
            </div>
        </aside>

        <div class="canvas-container" id="canvasContainer">
            <div class="canvas" id="canvas">
                <div class="canvas-content" id="canvasContent">
                    <svg class="connections-layer" id="connectionsLayer">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#5C5C6D"/>
                            </marker>
                            <marker id="arrowhead-selected" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#00D4AA"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
                
                <div class="empty-state" id="emptyState">
                    <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                    </svg>
                    <h3 class="empty-state-title">Start Building Your Workflow</h3>
                    <p class="empty-state-text">Drag nodes from the palette to create your first agent pipeline</p>
                </div>
            </div>
            
            <div class="shortcuts-hint">
                <span class="shortcut"><kbd>Del</kbd> Delete</span>
                <span class="shortcut"><kbd>Ctrl+Z</kbd> Undo</span>
                <span class="shortcut"><kbd>Ctrl+Shift+Z</kbd> Redo</span>
                <span class="shortcut"><kbd>Scroll</kbd> Zoom</span>
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">âˆ’</button>
                <span class="zoom-level" id="zoomLevel">100%</span>
                <button class="zoom-btn" id="zoomIn">+</button>
            </div>
        </div>

        <aside class="properties-panel" id="propertiesPanel">
            <div class="properties-header">
                <h3 class="properties-title">Properties</h3>
                <button class="properties-close" id="closeProperties">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="properties-content" id="propertiesContent">
                <div class="no-selection">
                    <svg class="no-selection-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 16v-4M12 8h.01"/>
                    </svg>
                    <p class="no-selection-text">Select a node to view and edit its properties</p>
                </div>
            </div>
        </aside>

        <div class="code-editor-panel" id="codeEditorPanel">
            <div class="code-editor-header">
                <span class="code-editor-title">workflow.json</span>
                <button class="btn" id="copyCode">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>
                    </svg>
                    Copy
                </button>
            </div>
            <div class="code-editor-container">
                <textarea class="code-editor" id="codeEditor" spellcheck="false"></textarea>
            </div>
        </div>
    </main>

    <input type="file" class="hidden-input" id="fileInput" accept=".json">

    <div class="toast" id="toast">
        <svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 11.08V12a10 10 0 11-5.93-9.14"/>
            <polyline points="22,4 12,14.01 9,11.01"/>
        </svg>
        <span id="toastMessage">Success!</span>
    </div>

    <script>
        // Application State
        const state = {
            nodes: [],
            connections: [],
            selectedNode: null,
            selectedConnection: null,
            mode: 'visual',
            zoom: 1,
            pan: { x: 0, y: 0 },
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            history: [],
            historyIndex: -1,
            nodeIdCounter: 0,
            connectionIdCounter: 0,
            isConnecting: false,
            connectionStart: null,
            tempConnection: null
        };

        // Node type configurations
        const nodeTypes = {
            agent: {
                title: 'Agent Node',
                color: 'var(--accent-primary)',
                description: 'Single agent invocation with I/O transformation',
                inputs: 1,
                outputs: 1,
                fields: [
                    { name: 'name', label: 'Name', type: 'text', required: true },
                    { name: 'class', label: 'Class', type: 'select', options: ['AssistantAgent', 'UserProxyAgent', 'ConversableAgent'] },
                    { name: 'systemMessage', label: 'System Message', type: 'textarea' },
                    { name: 'model', label: 'Model', type: 'text', placeholder: 'gpt-4' },
                    { name: 'temperature', label: 'Temperature', type: 'number', step: 0.1, min: 0, max: 2 },
                    { name: 'maxTokens', label: 'Max Tokens', type: 'number' },
                    { name: 'tools', label: 'Tools', type: 'textarea', placeholder: 'tool1, tool2' }
                ]
            },
            groupchat: {
                title: 'Group Chat',
                color: 'var(--accent-secondary)',
                description: 'Multi-agent conversation with manager mediation',
                inputs: 2,
                outputs: 1,
                fields: [
                    { name: 'name', label: 'Name', type: 'text', required: true },
                    { name: 'agents', label: 'Agents', type: 'textarea', placeholder: 'agent1, agent2' },
                    { name: 'selectionStrategy', label: 'Selection Strategy', type: 'select', options: ['auto', 'round_robin', 'random'] },
                    { name: 'maxRounds', label: 'Max Rounds', type: 'number' }
                ]
            },
            sequential: {
                title: 'Sequential',
                color: 'var(--accent-tertiary)',
                description: 'Ordered execution with output chaining',
                inputs: 2,
                outputs: 1,
                fields: [
                    { name: 'name', label: 'Name', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea' }
                ]
            },
            parallel: {
                title: 'Parallel',
                color: 'var(--accent-quaternary)',
                description: 'Concurrent execution with result aggregation',
                inputs: 2,
                outputs: 2,
                fields: [
                    { name: 'name', label: 'Name', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea' }
                ]
            }
        };

        // DOM Elements
        const canvas = document.getElementById('canvas');
        const canvasContent = document.getElementById('canvasContent');
        const connectionsLayer = document.getElementById('connectionsLayer');
        const emptyState = document.getElementById('emptyState');
        const propertiesPanel = document.getElementById('propertiesPanel');
        const propertiesContent = document.getElementById('propertiesContent');
        const codeEditorPanel = document.getElementById('codeEditorPanel');
        const codeEditor = document.getElementById('codeEditor');
        const zoomLevel = document.getElementById('zoomLevel');

        // Initialize
        function init() {
            loadFromLocalStorage();
            setupEventListeners();
            render();
        }

        // Event Listeners
        function setupEventListeners() {
            // Mode toggle
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.mode = btn.dataset.mode;
                    updateMode();
                });
            });

            // Palette drag
            document.querySelectorAll('.palette-item').forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });

            // Canvas drop
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('drop', handleDrop);

            // Canvas interactions
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });

            // Keyboard
            document.addEventListener('keydown', handleKeyDown);

            // Buttons
            document.getElementById('generateBtn').addEventListener('click', generateCode);
            document.getElementById('exportBtn').addEventListener('click', exportWorkflow);
            document.getElementById('importBtn').addEventListener('click', () => document.getElementById('fileInput').click());
            document.getElementById('fileInput').addEventListener('change', importWorkflow);
            document.getElementById('copyCode').addEventListener('click', copyCode);
            document.getElementById('closeProperties').addEventListener('click', deselectNode);
            document.getElementById('zoomIn').addEventListener('click', () => zoom(0.1));
            document.getElementById('zoomOut').addEventListener('click', () => zoom(-0.1));
        }

        // Drag and Drop
        let draggedType = null;

        function handleDragStart(e) {
            draggedType = e.target.closest('.palette-item').dataset.type;
            e.dataTransfer.effectAllowed = 'copy';
        }

        function handleDragEnd() {
            draggedType = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDrop(e) {
            e.preventDefault();
            if (!draggedType) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - state.pan.x) / state.zoom;
            const y = (e.clientY - rect.top - state.pan.y) / state.zoom;

            // Snap to grid
            const snappedX = Math.round(x / 20) * 20;
            const snappedY = Math.round(y / 20) * 20;

            createNode(draggedType, snappedX, snappedY);
        }

        // Node Operations
        function createNode(type, x, y) {
            const config = nodeTypes[type];
            const node = {
                id: `node_${++state.nodeIdCounter}`,
                type,
                x,
                y,
                data: {
                    name: `new_${type}_${state.nodeIdCounter}`,
                    description: config.description
                }
            };

            // Add default values based on type
            if (type === 'agent') {
                node.data.class = 'AssistantAgent';
                node.data.model = 'gpt-4';
                node.data.temperature = 0.3;
            } else if (type === 'groupchat') {
                node.data.selectionStrategy = 'auto';
                node.data.maxRounds = 10;
            }

            state.nodes.push(node);
            saveState();
            render();
            selectNode(node.id);
            showToast('Node created');
        }

        function deleteNode(nodeId) {
            state.nodes = state.nodes.filter(n => n.id !== nodeId);
            state.connections = state.connections.filter(c => c.fromNode !== nodeId && c.toNode !== nodeId);
            if (state.selectedNode === nodeId) {
                deselectNode();
            }
            saveState();
            render();
            showToast('Node deleted');
        }

        function selectNode(nodeId) {
            state.selectedNode = nodeId;
            render();
            renderPropertiesPanel();
        }

        function deselectNode() {
            state.selectedNode = null;
            render();
            renderPropertiesPanel();
        }

        function updateNodeData(nodeId, key, value) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                node.data[key] = value;
                saveState();
                
                // Update node title if name changed
                if (key === 'name') {
                    render();
                }
            }
        }

        // Connection Operations
        function createConnection(fromNode, toNode) {
            // Prevent self-connections
            if (fromNode === toNode) return;
            
            // Prevent duplicate connections
            const exists = state.connections.some(c => c.fromNode === fromNode && c.toNode === toNode);
            if (exists) return;

            // Prevent circular dependencies
            if (wouldCreateCycle(fromNode, toNode)) {
                showToast('Cannot create circular dependency', 'error');
                return;
            }

            const connection = {
                id: `conn_${++state.connectionIdCounter}`,
                fromNode,
                toNode
            };

            state.connections.push(connection);
            saveState();
            render();
            showToast('Connection created');
        }

        function deleteConnection(connId) {
            state.connections = state.connections.filter(c => c.id !== connId);
            if (state.selectedConnection === connId) {
                state.selectedConnection = null;
            }
            saveState();
            render();
            showToast('Connection deleted');
        }

        function wouldCreateCycle(fromNode, toNode) {
            const visited = new Set();
            const stack = [toNode];
            
            while (stack.length > 0) {
                const current = stack.pop();
                if (current === fromNode) return true;
                if (visited.has(current)) continue;
                visited.add(current);
                
                state.connections
                    .filter(c => c.fromNode === current)
                    .forEach(c => stack.push(c.toNode));
            }
            return false;
        }

        // Canvas Interactions
        let isPanning = false;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };

        function handleCanvasClick(e) {
            if (e.target === canvas || e.target === canvasContent) {
                deselectNode();
            }
        }

        function handleMouseDown(e) {
            const nodeEl = e.target.closest('.canvas-node');
            
            if (e.target.classList.contains('port') && e.target.classList.contains('output')) {
                // Start connection
                const nodeId = e.target.closest('.canvas-node').dataset.id;
                state.isConnecting = true;
                state.connectionStart = nodeId;
                
                // Create temp connection line
                const rect = canvas.getBoundingClientRect();
                const startX = (e.clientX - rect.left - state.pan.x) / state.zoom;
                const startY = (e.clientY - rect.top - state.pan.y) / state.zoom;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('id', 'temp-connection');
                path.setAttribute('class', 'connection');
                path.setAttribute('stroke', 'var(--accent-primary)');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.style.pointerEvents = 'none';
                connectionsLayer.appendChild(path);
                
                state.tempConnection = { path, startX, startY, endX: startX, endY: startY };
                return;
            }

            if (nodeEl) {
                const nodeId = nodeEl.dataset.id;
                
                if (e.button === 0) {
                    draggedNode = nodeId;
                    const node = state.nodes.find(n => n.id === nodeId);
                    const rect = nodeEl.getBoundingClientRect();
                    dragOffset = {
                        x: (e.clientX - rect.left) / state.zoom,
                        y: (e.clientY - rect.top) / state.zoom
                    };
                    selectNode(nodeId);
                }
            } else if (e.target === canvas || e.target === canvasContent) {
                // Start panning
                isPanning = true;
                state.dragStart = { x: e.clientX, y: e.clientY };
            }
        }

        function handleMouseMove(e) {
            if (state.isConnecting && state.tempConnection) {
                const rect = canvas.getBoundingClientRect();
                state.tempConnection.endX = (e.clientX - rect.left - state.pan.x) / state.zoom;
                state.tempConnection.endY = (e.clientY - rect.top - state.pan.y) / state.zoom;
                updateTempConnection();
                return;
            }

            if (draggedNode) {
                const node = state.nodes.find(n => n.id === draggedNode);
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - state.pan.x) / state.zoom - dragOffset.x;
                const y = (e.clientY - rect.top - state.pan.y) / state.zoom - dragOffset.y;
                
                // Snap to grid
                node.x = Math.round(x / 20) * 20;
                node.y = Math.round(y / 20) * 20;
                
                render();
            } else if (isPanning) {
                const dx = e.clientX - state.dragStart.x;
                const dy = e.clientY - state.dragStart.y;
                state.pan.x += dx;
                state.pan.y += dy;
                state.dragStart = { x: e.clientX, y: e.clientY };
                updateCanvasTransform();
            }
        }

        function handleMouseUp(e) {
            if (state.isConnecting) {
                // Check if we're over an input port
                const port = e.target.closest('.port.input');
                if (port) {
                    const targetNode = port.closest('.canvas-node').dataset.id;
                    createConnection(state.connectionStart, targetNode);
                }
                
                // Remove temp connection
                const tempPath = document.getElementById('temp-connection');
                if (tempPath) tempPath.remove();
                state.tempConnection = null;
                state.isConnecting = false;
                state.connectionStart = null;
            }

            if (draggedNode) {
                saveState();
                draggedNode = null;
            }

            isPanning = false;
        }

        function updateTempConnection() {
            if (!state.tempConnection) return;
            
            const { startX, startY, endX, endY } = state.tempConnection;
            const path = document.getElementById('temp-connection');
            
            // Bezier curve
            const midX = (startX + endX) / 2;
            const d = `M ${startX + 110} ${startY} C ${midX + 110} ${startY}, ${midX} ${endY}, ${endX} ${endY}`;
            path.setAttribute('d', d);
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoom(delta, e.clientX, e.clientY);
        }

        function zoom(delta, centerX, centerY) {
            const oldZoom = state.zoom;
            state.zoom = Math.max(0.5, Math.min(2, state.zoom + delta));
            
            if (centerX !== undefined && centerY !== undefined) {
                const rect = canvas.getBoundingClientRect();
                const x = centerX - rect.left;
                const y = centerY - rect.top;
                
                const zoomRatio = state.zoom / oldZoom;
                state.pan.x = x - (x - state.pan.x) * zoomRatio;
                state.pan.y = y - (y - state.pan.y) * zoomRatio;
            }
            
            updateCanvasTransform();
        }

        function updateCanvasTransform() {
            canvasContent.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.zoom})`;
            zoomLevel.textContent = `${Math.round(state.zoom * 100)}%`;
        }

        // Keyboard
        function handleKeyDown(e) {
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;
            
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (state.selectedNode) {
                    deleteNode(state.selectedNode);
                } else if (state.selectedConnection) {
                    deleteConnection(state.selectedConnection);
                }
            }

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        redo();
                    } else {
                        undo();
                    }
                }
            }
        }

        // Rendering
        function render() {
            // Clear existing nodes
            document.querySelectorAll('.canvas-node').forEach(el => el.remove());
            
            // Update empty state
            emptyState.style.display = state.nodes.length === 0 ? 'block' : 'none';

            // Render nodes
            state.nodes.forEach(node => {
                const el = createNodeElement(node);
                canvasContent.appendChild(el);
            });

            // Render connections
            renderConnections();
        }

        function createNodeElement(node) {
            const config = nodeTypes[node.type];
            const el = document.createElement('div');
            el.className = `canvas-node ${node.type}${state.selectedNode === node.id ? ' selected' : ''}`;
            el.dataset.id = node.id;
            el.style.left = `${node.x}px`;
            el.style.top = `${node.y}px`;

            const typeIcon = getNodeIcon(node.type);

            el.innerHTML = `
                <div class="port input"></div>
                <div class="node-header">
                    <div class="node-type-icon ${node.type}">
                        ${typeIcon}
                    </div>
                    <span class="node-title">${node.data.name || config.title}</span>
                </div>
                <div class="node-body">
                    <p class="node-description">${node.data.description || config.description}</p>
                </div>
                <div class="port output"></div>
            `;

            return el;
        }

        function getNodeIcon(type) {
            const icons = {
                agent: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>',
                groupchat: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87M16 3.13a4 4 0 010 7.75"/></svg>',
                sequential: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg>',
                parallel: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"/></svg>'
            };
            return icons[type] || '';
        }

        function renderConnections() {
            // Clear existing connections (except temp and defs)
            const existingPaths = connectionsLayer.querySelectorAll('path:not(#temp-connection)');
            existingPaths.forEach(p => p.remove());

            state.connections.forEach(conn => {
                const fromNode = state.nodes.find(n => n.id === conn.fromNode);
                const toNode = state.nodes.find(n => n.id === conn.toNode);
                
                if (!fromNode || !toNode) return;

                const fromX = fromNode.x + 220;
                const fromY = fromNode.y + 50;
                const toX = toNode.x;
                const toY = toNode.y + 50;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', `connection${state.selectedConnection === conn.id ? ' selected' : ''}`);
                path.setAttribute('id', conn.id);
                path.setAttribute('marker-end', state.selectedConnection === conn.id ? 'url(#arrowhead-selected)' : 'url(#arrowhead)');
                
                // Bezier curve
                const midX = (fromX + toX) / 2;
                const d = `M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}`;
                path.setAttribute('d', d);
                
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.selectedConnection = conn.id;
                    render();
                });
                
                connectionsLayer.appendChild(path);
            });
        }

        // Properties Panel
        function renderPropertiesPanel() {
            if (!state.selectedNode) {
                propertiesContent.innerHTML = `
                    <div class="no-selection">
                        <svg class="no-selection-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 16v-4M12 8h.01"/>
                        </svg>
                        <p class="no-selection-text">Select a node to view and edit its properties</p>
                    </div>
                `;
                return;
            }

            const node = state.nodes.find(n => n.id === state.selectedNode);
            const config = nodeTypes[node.type];

            let html = `
                <div class="form-group">
                    <label class="form-label">Type</label>
                    <input type="text" class="form-input" value="${config.title}" disabled>
                </div>
            `;

            config.fields.forEach(field => {
                let inputHtml = '';
                const value = node.data[field.name] || '';

                if (field.type === 'select') {
                    inputHtml = `
                        <select class="form-input form-select" data-field="${field.name}">
                            ${field.options.map(opt => `<option value="${opt}"${value === opt ? ' selected' : ''}>${opt}</option>`).join('')}
                        </select>
                    `;
                } else if (field.type === 'textarea') {
                    inputHtml = `<textarea class="form-input form-textarea" data-field="${field.name}" placeholder="${field.placeholder || ''}">${value}</textarea>`;
                } else if (field.type === 'number') {
                    inputHtml = `<input type="number" class="form-input" data-field="${field.name}" value="${value}" step="${field.step || 1}" min="${field.min || 0}" max="${field.max || ''}" placeholder="${field.placeholder || ''}">`;
                } else {
                    inputHtml = `<input type="text" class="form-input" data-field="${field.name}" value="${value}" placeholder="${field.placeholder || ''}">`;
                }

                html += `
                    <div class="form-group">
                        <label class="form-label">${field.label}${field.required ? ' *' : ''}</label>
                        ${inputHtml}
                    </div>
                `;
            });

            // Add LLM Config section for agent nodes
            if (node.type === 'agent') {
                html += `
                    <div class="form-group">
                        <label class="form-label">LLM Configuration</label>
                        <div class="form-row">
                            <input type="text" class="form-input" placeholder="Model" value="${node.data.model || ''}" data-field="model">
                            <input type="number" class="form-input" placeholder="Temperature" value="${node.data.temperature || ''}" step="0.1" data-field="temperature">
                        </div>
                    </div>
                `;
            }

            propertiesContent.innerHTML = html;

            // Add event listeners
            propertiesContent.querySelectorAll('[data-field]').forEach(input => {
                input.addEventListener('change', (e) => {
                    let value = e.target.value;
                    if (e.target.type === 'number') {
                        value = parseFloat(value) || 0;
                    }
                    updateNodeData(state.selectedNode, e.target.dataset.field, value);
                });
            });
        }

        // Mode Switching
        function updateMode() {
            if (state.mode === 'code') {
                generateCode();
                codeEditorPanel.classList.add('active');
                propertiesPanel.style.display = 'none';
                canvas.style.display = 'none';
                document.getElementById('palette').style.display = 'none';
            } else {
                codeEditorPanel.classList.remove('active');
                propertiesPanel.style.display = 'flex';
                canvas.style.display = 'block';
                document.getElementById('palette').style.display = 'block';
                
                // Parse code back to visual
                try {
                    const json = JSON.parse(codeEditor.value);
                    loadFromJSON(json);
                } catch (e) {
                    // Invalid JSON, keep current state
                }
            }
        }

        // Code Generation
        function generateCode() {
            const workflow = {
                schema_version: "2.0",
                workflow_id: `workflow-${Date.now()}`,
                agents: [],
                orchestration: {
                    type: "Sequential",
                    agents: []
                }
            };

            // Extract agents from nodes
            const agentNodes = state.nodes.filter(n => n.type === 'agent');
            agentNodes.forEach(node => {
                const agent = {
                    name: node.data.name,
                    class: node.data.class || 'AssistantAgent',
                    system_message: node.data.systemMessage || '',
                    llm_config: {
                        model: node.data.model || 'gpt-4',
                        temperature: node.data.temperature || 0.3
                    },
                    tools: node.data.tools ? node.data.tools.split(',').map(t => t.trim()) : []
                };
                workflow.agents.push(agent);
                workflow.orchestration.agents.push(node.data.name);
            });

            // Determine orchestration type from nodes
            const hasGroupChat = state.nodes.some(n => n.type === 'groupchat');
            const hasParallel = state.nodes.some(n => n.type === 'parallel');
            
            if (hasGroupChat) {
                workflow.orchestration.type = "GroupChat";
                workflow.orchestration.manager = {
                    selection_strategy: "auto",
                    max_rounds: 10
                };
            } else if (hasParallel) {
                workflow.orchestration.type = "Parallel";
            }

            const json = JSON.stringify(workflow, null, 2);
            
            if (state.mode === 'code') {
                codeEditor.value = json;
            }
            
            return json;
        }

        // Export/Import
        function exportWorkflow() {
            const data = {
                nodes: state.nodes,
                connections: state.connections
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workflow.json';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Workflow exported');
        }

        function importWorkflow(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    state.nodes = data.nodes || [];
                    state.connections = data.connections || [];
                    
                    // Update counters
                    state.nodeIdCounter = Math.max(0, ...state.nodes.map(n => parseInt(n.id.split('_')[1]) || 0));
                    state.connectionIdCounter = Math.max(0, ...state.connections.map(c => parseInt(c.id.split('_')[1]) || 0));
                    
                    saveState();
                    render();
                    showToast('Workflow imported');
                } catch (err) {
                    showToast('Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function copyCode() {
            codeEditor.select();
            document.execCommand('copy');
            showToast('Code copied to clipboard');
        }

        // History (Undo/Redo)
        function saveState() {
            const snapshot = JSON.stringify({
                nodes: state.nodes,
                connections: state.connections
            });
            
            // Remove future states if we're not at the end
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(snapshot);
            state.historyIndex++;
            
            // Limit history size
            if (state.history.length > 50) {
                state.history.shift();
                state.historyIndex--;
            }
            
            localStorage.setItem('workflow', snapshot);
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('workflow');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    state.nodes = data.nodes || [];
                    state.connections = data.connections || [];
                    state.nodeIdCounter = Math.max(0, ...state.nodes.map(n => parseInt(n.id.split('_')[1]) || 0));
                    state.connectionIdCounter = Math.max(0, ...state.connections.map(c => parseInt(c.id.split('_')[1]) || 0));
                } catch (e) {
                    // Invalid data, start fresh
                }
            }
        }

        function loadFromJSON(json) {
            if (!json.agents) return;
            
            // Clear current state
            state.nodes = [];
            state.connections = [];
            
            // Create nodes from agents
            let x = 100, y = 100;
            json.agents.forEach((agent, i) => {
                state.nodes.push({
                    id: `node_${++state.nodeIdCounter}`,
                    type: 'agent',
                    x,
                    y,
                    data: {
                        name: agent.name,
                        class: agent.class,
                        systemMessage: agent.system_message,
                        model: agent.llm_config?.model,
                        temperature: agent.llm_config?.temperature,
                        tools: agent.tools?.join(', ')
                    }
                });
                y += 150;
            });
            
            // Create sequential connections
            for (let i = 0; i < state.nodes.length - 1; i++) {
                state.connections.push({
                    id: `conn_${++state.connectionIdCounter}`,
                    fromNode: state.nodes[i].id,
                    toNode: state.nodes[i + 1].id
                });
            }
            
            render();
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                const snapshot = JSON.parse(state.history[state.historyIndex]);
                state.nodes = snapshot.nodes;
                state.connections = snapshot.connections;
                localStorage.setItem('workflow', state.history[state.historyIndex]);
                render();
                showToast('Undone');
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                const snapshot = JSON.parse(state.history[state.historyIndex]);
                state.nodes = snapshot.nodes;
                state.connections = snapshot.connections;
                localStorage.setItem('workflow', state.history[state.historyIndex]);
                render();
                showToast('Redone');
            }
        }

        // Toast
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            
            toast.className = `toast ${type}`;
            toastMessage.textContent = message;
            
            // Update icon
            const icon = toast.querySelector('.toast-icon');
            if (type === 'error') {
                icon.innerHTML = '<circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6M9 9l6 6"/>';
            } else {
                icon.innerHTML = '<path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22,4 12,14.01 9,11.01"/>';
            }
            
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Start
        init();
    </script>
</body>
</html>
