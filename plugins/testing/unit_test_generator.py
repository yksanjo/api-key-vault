"""
Unit test generator plugin.
"""

import re
from typing import Any, Dict, List, Optional
from pydantic import Field

from plugins.base import BasePlugin, BasePluginConfig


class UnitTestGeneratorConfig(BasePluginConfig):
    """Configuration for unit test generator."""
    framework: str = Field(default="pytest", description="Test framework (pytest, unittest)")
    include_init: bool = Field(
        default=True,
        description="Include __init__ methods in tests"
    )


class UnitTestGenerator(BasePlugin):
    """
    Generate unit tests for various programming languages.
    """
    
    name = "unit_test_generator"
    version = "1.0.0"
    author = "Multi-Agent Plugins"
    description = "Generate unit tests for code"
    tags = ["testing", "unit-test", "code-generation"]
    config_class = UnitTestGeneratorConfig
    
    def execute(self, **kwargs) -> Dict[str, Any]:
        """
        Generate unit tests.
        
        Args:
            source_file: Path to source file
            source_code: Source code as string
            framework: Test framework (pytest, unittest)
            language: Programming language
            **kwargs: Additional options
            
        Returns:
            Dictionary with generated tests
        """
        framework = kwargs.get("framework", self.config.framework)
        source_code = kwargs.get("source_code")
        source_file = kwargs.get("source_file")
        
        if not source_code and source_file:
            try:
                with open(source_file, 'r') as f:
                    source_code = f.read()
            except FileNotFoundError:
                return {"error": f"File not found: {source_file}"}
        
        if not source_code:
            return {"error": "No source code provided"}
        
        language = kwargs.get("language", "python")
        
        if framework == "pytest":
            return self._generate_pytest(source_code, language)
        elif framework == "unittest":
            return self._generate_unittest(source_code, language)
        else:
            return {"error": f"Unknown framework: {framework}"}
    
    def _generate_pytest(self, source_code: str, language: str) -> Dict[str, Any]:
        """Generate pytest tests."""
        # Extract classes and functions from source
        classes = self._extract_classes(source_code)
        functions = self._extract_functions(source_code)
        
        test_code = '"""Unit tests generated by Multi-Agent Plugins"""\nimport pytest\n\n\n'
        
        # Generate class tests
        for cls in classes:
            test_code += f'class Test{cls["name"]}:\n    """Tests for {cls["name"]}"""\n\n'
            
            # Test __init__ if present
            if cls.get("has_init"):
                test_code += f'    def test_init(self):\n        """Test {cls["name"]} initialization"""\n        # TODO: Add test implementation\n        pass\n\n'
            
            # Test methods
            for method in cls.get("methods", []):
                test_code += f'    def test_{method["name"]}(self):\n        """Test {method["name"]} method"""\n        # TODO: Add test implementation\n        pass\n\n'
        
        # Generate function tests
        for func in functions:
            test_code += f'def test_{func["name"]}():\n    """Test {func["name"]} function"""\n    # TODO: Add test implementation\n    pass\n\n'
        
        return {
            "code": test_code,
            "framework": "pytest",
            "filename": "test_generated.py",
            "classes_tested": len(classes),
            "functions_tested": len(functions)
        }
    
    def _generate_unittest(self, source_code: str, language: str) -> Dict[str, Any]:
        """Generate unittest tests."""
        classes = self._extract_classes(source_code)
        functions = self._extract_functions(source_code)
        
        test_code = '"""Unit tests generated by Multi-Agent Plugins"""\nimport unittest\n\n\n'
        
        # Generate class tests
        for cls in classes:
            test_code += f'class Test{cls["name"]}(unittest.TestCase):\n    """Tests for {cls["name"]}"""\n\n'
            
            # Test __init__ if present
            if cls.get("has_init"):
                test_code += f'    def test_init(self):\n        """Test {cls["name"]} initialization"""\n        # TODO: Add test implementation\n        self.assertTrue(True)\n\n'
            
            # Test methods
            for method in cls.get("methods", []):
                test_code += f'    def test_{method["name"]}(self):\n        """Test {method["name"]} method"""\n        # TODO: Add test implementation\n        self.assertTrue(True)\n\n'
        
        test_code += '\nif __name__ == "__main__":\n    unittest.main()\n'
        
        return {
            "code": test_code,
            "framework": "unittest",
            "filename": "test_generated.py",
            "classes_tested": len(classes),
            "functions_tested": len(functions)
        }
    
    def _extract_classes(self, source_code: str) -> List[Dict[str, Any]]:
        """Extract class definitions from source code."""
        classes = []
        
        # Match class definitions
        pattern = r'class\s+(\w+)(?:\(([^)]+)\))?:'
        matches = re.finditer(pattern, source_code)
        
        for match in matches:
            cls_name = match.group(1)
            cls = {"name": cls_name, "methods": [], "has_init": False}
            
            # Find methods in the class
            class_body_start = match.end()
            # Simple approach - find next class or end
            class_match = re.search(r'class\s+\w+', source_code[class_body_start:])
            class_end = class_match.start() + class_body_start if class_match else len(source_code)
            
            class_source = source_code[match.start():class_end]
            
            # Check for __init__
            if '__init__' in class_source:
                cls["has_init"] = True
            
            # Extract methods
            method_pattern = r'def\s+(\w+)\s*\('
            for method_match in re.finditer(method_pattern, class_source):
                method_name = method_match.group(1)
                if not method_name.startswith('_') or method_name == '__init__':
                    cls["methods"].append({"name": method_name})
            
            classes.append(cls)
        
        return classes
    
    def _extract_functions(self, source_code: str) -> List[Dict[str, Any]]:
        """Extract function definitions from source code."""
        functions = []
        
        # Match function definitions (not methods)
        pattern = r'^def\s+(\w+)\s*\([^)]*\):'
        for match in re.finditer(pattern, source_code, re.MULTILINE):
            func_name = match.group(1)
            # Skip private functions
            if not func_name.startswith('_'):
                functions.append({"name": func_name})
        
        return functions
